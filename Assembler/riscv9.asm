.data
array_0: .space 400000
array_1: .space 400000
array_2: .space 400000
newline: .asciz "\n"
.text
	la t0 array_0
	mv a1 t0
	li a7 5
	mv s0 zero
loop_1:
	ecall 
	sw a0 (t0)
	addi t0 t0 4
	addi s0 s0 1
	bne a0 zero loop_1
	
	mv a2 s0
	la a0 array_1
	jal jsort
	j end_programm
jsort:
    # Сохраняем регистры на стеке
    addi sp, sp, -16        # Выделяем место на стеке
    sw ra, 12(sp)           # Сохраняем адрес возврата
    sw a0, 8(sp)            # Сохраняем a0 (адрес массива-приемника)
    sw a1, 4(sp)            # Сохраняем a1 (адрес исходного массива)
    sw a2, 0(sp)            # Сохраняем a2 (количество элементов)

    # Базовый случай: если N <= 1, просто копируем элемент
    li t0, 1
    bge a2, t0, sort

    # Если N > 1, делим массив на две половины
    srai t1, a2, 1          # t1 = N / 2
    mv t2, a1               # t2 = адрес начала исходного массива
    addi t3, t2, 4          # t3 = адрес середины массива (t2 + 4)

    # Рекурсивно сортируем левую половину
    jal jsort                # jsort(левый массив, адрес, N/2)
    mv a1, t3               # Подготовка для правой половины
    mv a2, t1               # Устанавливаем N/2 для правой половины

    # Рекурсивно сортируем правую половину
    jal jsort                # jsort(правый массив, адрес середины, N/2)

    # Объединяем отсортированные половины
    lw a0, 8(sp)            # Восстанавливаем адрес массива-приемника
    lw a1, 4(sp)            # Восстанавливаем адрес исходного массива
    lw a2, 0(sp)            # Восстанавливаем количество элементов
    jal join                # join(приемник, левый массив, правый массив, N/2)

    # Восстанавливаем регистры и возвращаемся
    lw ra, 12(sp)           # Восстанавливаем адрес возврата
    addi sp, sp, 16         # Освобождаем место на стеке
    ret

sort:
    # Базовый случай: если N <= 1, просто копируем элемент
    lw t0, 0(sp)            # Восстанавливаем количество элементов
    beq t0, zero, end_jsort # Если N == 0, завершаем
    lw t1, 4(sp)            # Восстанавливаем адрес исходного массива
    lw t2, 8(sp)            # Восстанавливаем адрес массива-приемника
    lw t3, 0(sp)            # Восстанавливаем количество элементов
    lw t4, (t1)             # Загружаем элемент
    sw t4, (t2)             # Сохраняем элемент в массив-приемник
    addi t2, t2, 4          # Увеличиваем адрес для следующего элемента
    addi t1, t1, 4          # Увеличиваем адрес исходного массива
    addi t3, t3, -1         # Уменьшаем количество элементов
    j sort                  # Повторяем

end_jsort:
    lw ra, 12(sp)           # Восстанавливаем адрес возврата
    addi sp, sp, 16         # Освобождаем место на стеке
    ret

join:
	mv t5 a0
	li t1 0
	li t2 0
loop:
	bge t1 a3 first
	bge t2 a3 second
	lw t3 (a1)
	lw t4 (a2)
	blt t3 t4 save
	sw t4 (a0)
	addi a0 a0 4
	addi a2 a2 4
	addi t2 t2 1
	j loop 
save: 
	sw t3 (a0) 
	addi a0 a0 4
	addi a1 a1 4
	addi t1 t1 1
	j loop
first: 
	lw t4 (a2)
	bge t2 a3 end
	sw t4 (a0)
	addi a0 a0 4
	addi a2 a2 4
	addi t2 t2 1
	lw t4 (a2)
	j first 
second: 
	lw t3 (a1)
	bge t1 a3 end
	sw t3 (a0)
	addi a0 a0 4
	addi a1 a1 4
	addi t1 t1 1
	lw t3 (a1)
	j second
end:	
	mv a0 t5
	ret
	
end_programm:
	li a7 10
	ecall